//! # A crate for CSI collection on ESP devices
//! ## Overview
//! This crate builds on the low level Espressif abstractions to enable the collection of Channel State Information (CSI) on ESP devices with ease.
//! Currently this crate supports only the ESP `no-std` development framework.
//!
//! ### Choosing a device
//! In terms of hardware, you need to make sure that the device you choose supports WiFI and CSI collection.
//! Currently supported deveices are:
//! - ESP32
//! - ESP32-C2
//! - ESP32-C3
//! - ESP32-C6
//! - ESP32-S3
//!
//! In terms of software toolchain setup, you will need to specify the hardware you will be using. To minimize headache, it is recommended that you generate a project using `esp-generate` as explained next.
//!
//! ### Creating a project
//! To use this crate you would need to create and setup a project for your ESP device then import the crate. This crate is compatible with `no-std` ESP development projects. You should also select the corresponding device by activating it in the crate features.
//!
//! To create a projects it is highly recommended to refer the to instructions in [The Rust on ESP Book](https://docs.esp-rs.org/book/) before proceeding. The book explains the full esp-rs ecosystem, how to get started, and how to generate projects for both `std` and `no-std`.
//!
//! Espressif has developed a project generation tool, `esp-generate`, to ease this process and is recommended for new projects. As an example, you can create a `no-std` project as follows:
//!
//! ```bash
//! cargo install esp-generate
//! esp-generate --chip=esp32c3 [project-name]
//! ```
//!
//! ## Feature Flags
#![doc = document_features::document_features!()]
//! ## Using the `esp-csi-rs` Crate
//! With the exception of sniffer mode, the collection of CSI requires at least two WiFI enabled devices; an Access Point and a Station. Both devices could be ESP devices one programmed as a Station and another as an Access Point. Alternatively, the simplest setup is using one ESP device as a Station connecting to an existing Access Point like a home router.
//! This crate supports creating both Access Points and Stations and there are several examples to demonstrate in the repository. When both devices are ESPs, the Access Point and the Station are able to collect CSI data.
//!
//! Additionally, to regularly recieve CSI data, there needs to be regular traffic on the network. The traffic needs to be generated by the crate. Traffic could be a simple ICMP ping or a UDP packet. ICMP is lightweight but carries no data. Alternatively, if desired, UDP can carry data. Currently the crate supports only ICMP and UDP. While access points will naturally respond to ICMP pings, currently UDP traffic is simply ignored.
//!
//! ### Example for Collecting CSI in Station Mode
//!
//! There are more examples in the repository. This example demonstrates how to collect CSI data with an ESP configured in Station mode.
//!
//! This configuration allows the collection of CSI data by connecting to a WiFi router or ESP Access Point.
//!
//! Connection Options:
//! - Option 1: Connect to an existing commercial router
//! - Option 2: Connect to another ESP programmed in AP Mode or AP/STA Mode
//!
//! The SSID and Password defined is for the Access Point or Router the ESP Station will be connecting to.
//!
//!
//! #### Step 1: Create a CSI Collection Configuration/Profile
//!```rust, no_run
//! let csi_collector = CSICollector::new(
//!     WiFiConfig {
//!         ssid: "AP_SSID".try_into().unwrap(),
//!         password: "AP_PASSWORD".try_into().unwrap(),
//!         ..Default::default()
//!     },
//!     esp_csi_rs::WiFiMode::Station,
//!     CSIConfig::default(),
//!     TrafficConfig {
//!         traffic_type: TrafficType::UDP,
//!         // Ex. Send traffic every one second
//!         traffic_interval_ms: 1000,
//!     },
//!     // Enable traffic
//!     true,
//!     // Define architecture deployed
//!     NetworkArchitechture::RouterStation,
//! );
//!```
//! #### Step 2: Initialize CSI Collection
//!```rust, no_run
//!csi_collector.init(wifi, init, seed, &spawner).unwrap();
//!```
//!
//! #### Step 3: Start Collection
//!```rust, no_run
//! // Starts Collection for 10 seconds then stops
//!csi_collector.start(10).await;
//!```
//!
//! Upon building and running the project, CSI data will appear in the serial monitor window
//!

#![no_std]

use core::cell::RefCell;
use core::sync::atomic::AtomicBool;
use embassy_executor::Spawner;
use embassy_time::{with_timeout, Duration, Instant, Timer};

#[cfg(feature = "println")]
use esp_println as _;
#[cfg(feature = "println")]
use esp_println::println;

#[cfg(feature = "defmt")]
use defmt::println;

use smoltcp::phy::ChecksumCapabilities;
use smoltcp::wire::{Icmpv4Packet, Icmpv4Repr, Ipv4Packet, Ipv4Repr};

use embassy_net::{
    raw::{IpProtocol, IpVersion, PacketMetadata as RawPacketMetadata, RawSocket},
    udp::{PacketMetadata, UdpSocket},
    IpAddress, IpEndpoint, Ipv4Address, Ipv4Cidr, Runner, Stack, StackResources, StaticConfigV4,
};
use esp_alloc as _;
use esp_backtrace as _;
use esp_hal::peripherals::WIFI;
use esp_wifi::{
    wifi::{
        AccessPointConfiguration, ClientConfiguration, Configuration, CsiConfig, WifiController,
        WifiDevice, WifiEvent, WifiState,
    },
    EspWifiController,
};

use enumset::enum_set;

use core::{net::Ipv4Addr, str::FromStr};
use embassy_sync::{
    blocking_mutex::raw::CriticalSectionRawMutex, blocking_mutex::Mutex, once_lock::OnceLock,
    signal::Signal,
};

use heapless::Vec;

pub mod config;
mod error;

use crate::config::*;
use crate::error::{Error, Result};

macro_rules! mk_static {
    ($t:ty,$val:expr) => {{
        static STATIC_CELL: static_cell::StaticCell<$t> = static_cell::StaticCell::new();
        #[deny(unused_attributes)]
        let x = STATIC_CELL.uninit().write(($val));
        x
    }};
}

const NTP_UNIX_OFFSET: u32 = 2_208_988_800; // 1900 to 1970 offset in seconds
const NTP_SERVER: &str = "pool.ntp.org";
const NTP_PORT: u16 = 123;

static DATE_TIME: OnceLock<DateTime> = OnceLock::new();
static START_COLLECTION: Signal<CriticalSectionRawMutex, u64> = Signal::new();
static DATE_TIME_VALID: AtomicBool = AtomicBool::new(false);
// static START_TRAFFIC_GEN: Signal<CriticalSectionRawMutex, ()> = Signal::new();

static CONTROLLER_CONFIG: Mutex<CriticalSectionRawMutex, RefCell<Option<Configuration>>> =
    Mutex::new(RefCell::new(None));
static NETWORK_CONFIG: Mutex<CriticalSectionRawMutex, RefCell<NetworkArchitechture>> =
    Mutex::new(RefCell::new(NetworkArchitechture::Sniffer));
static COLLECTION_CONFIG: Mutex<CriticalSectionRawMutex, RefCell<Option<CSIConfig>>> =
    Mutex::new(RefCell::new(None));
static OPERATION_MODE: Mutex<CriticalSectionRawMutex, RefCell<WiFiMode>> =
    Mutex::new(RefCell::new(WiFiMode::Sniffer));

// Date Time Struct
#[derive(Debug, Clone)]
struct DateTime {
    captured_at: Instant,
    captured_secs: u64,
    captured_millis: u64,
}

/// Device operation modes
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum WiFiMode {
    /// Access Point mode
    AccessPoint,
    /// Station (client) mode
    Station,
    /// Access Point + Station mode
    AccessPointStation,
    /// Monitor (sniffer) mode
    Sniffer,
}

/// Network Architechture Options
#[derive(Debug, Clone, Copy)]
pub enum NetworkArchitechture {
    /// Router Connected to One Station
    RouterStation,
    /// Router Connected to Access Point + Station Connected to One or More Station(s)
    RouterAccessPointStation,
    /// Access Point Connected to One or More Station(s)
    AccessPointStation,
    /// Standalone Station (Sniffer)
    Sniffer,
}

#[derive(Debug, Clone)]
pub struct IpInfo {
    pub local_address: Ipv4Cidr,
    pub gateway_address: Ipv4Address,
}

/// Main Driver Struct for CSI Collection
#[derive(Debug, Clone)]
pub struct CSICollector {
    /// WiFi Configuration
    pub wifi_config: WiFiConfig,
    /// Device Operation Mode
    pub op_mode: WiFiMode,
    /// CSI Collection Parameters
    pub csi_config: CSIConfig,
    /// Traffic Generator Configuration
    pub traffic_config: TrafficConfig,
    /// Traffic Generation Enable
    pub traffic_enabled: bool,
    /// Network Architechture Option
    pub net_arch: NetworkArchitechture,
}

impl CSICollector {
    /// Creates a new CSICollector instance with a defined configuration/profile.
    pub fn new(
        wifi_config: WiFiConfig,
        op_mode: WiFiMode,
        csi_config: CSIConfig,
        traffic_config: TrafficConfig,
        traffic_enabled: bool,
        net_arch: NetworkArchitechture,
    ) -> Self {
        Self {
            wifi_config,
            op_mode,
            csi_config,
            traffic_config,
            traffic_enabled,
            net_arch,
        }
    }

    /// Creates a new CSICollector instance with default configuration.
    /// Device is set to Sniffer mode by default.
    /// Generally you should resort to the `new` method unless you want to only snif packets.
    pub fn new_with_defaults() -> Self {
        Self {
            wifi_config: WiFiConfig::default(),
            op_mode: WiFiMode::Sniffer,
            csi_config: CSIConfig::default(),
            traffic_config: TrafficConfig::default(),
            traffic_enabled: false,
            net_arch: NetworkArchitechture::Sniffer,
        }
    }

    /// Starts CSI Collection
    pub async fn start(&self, collection_time_secs: u64) {
        // In this method everytime the collection starts, the new configurations are loaded and propagated to global context.
        // All settings can be copied from new configuration and loaded to global, without needing to initalize again.
        // Initialization should be restriced to setting up hardware an spawning the network tasks.
        // Everything else should be done here.

        // Example use case, if any setting is updated (Ex. SSID or Password), I would be able to load new config on collection restart

        // Load configurations into global context
        COLLECTION_CONFIG.lock(|c| c.borrow_mut().replace(self.csi_config.clone()));
        NETWORK_CONFIG.lock(|c| *c.borrow_mut() = self.net_arch.clone());
        OPERATION_MODE.lock(|op| *op.borrow_mut() = self.op_mode.clone());

        match self.op_mode {
            WiFiMode::AccessPoint => {
                // Capture SSID and Password from provided configuration
                let ap_ssid = self.wifi_config.ap_ssid.clone();
                let ap_password = self.wifi_config.ap_password.clone();
                let channel = self.wifi_config.channel.clone();
                let max_connections = self.wifi_config.max_connections.clone();
                let hide_ssid = self.wifi_config.ssid_hidden.clone();

                // Access Point Configuration
                let ap_config = Configuration::AccessPoint(AccessPointConfiguration {
                    ssid: ap_ssid.try_into().unwrap(),
                    auth_method: esp_wifi::wifi::AuthMethod::WPA2Personal,
                    password: ap_password.try_into().unwrap(),
                    max_connections: max_connections,
                    channel: channel,
                    ssid_hidden: hide_ssid,
                    ..Default::default()
                });

                // Store AP Controller Configuration in Global Context
                CONTROLLER_CONFIG.lock(|c| c.borrow_mut().replace(ap_config));
            }
            WiFiMode::AccessPointStation => {
                // Capture Access Point SSID and Password from provided configuration
                let ap_ssid = self.wifi_config.ap_ssid.clone();
                let ap_password = self.wifi_config.ap_password.clone();
                let channel = self.wifi_config.channel.clone();
                let max_connections = self.wifi_config.max_connections.clone();
                let hide_ssid = self.wifi_config.ssid_hidden.clone();

                // Capture Station SSID and Password from provided configuration
                let ssid = self.wifi_config.ssid.clone();
                let password = self.wifi_config.password.clone();

                // AP/STA Configuration
                let config = Configuration::Mixed(
                    ClientConfiguration {
                        ssid: ssid.try_into().unwrap(),
                        password: password.try_into().unwrap(),
                        channel: Some(self.wifi_config.channel),
                        auth_method: esp_wifi::wifi::AuthMethod::WPA2Personal,
                        ..Default::default()
                    },
                    AccessPointConfiguration {
                        ssid: ap_ssid.try_into().unwrap(),
                        auth_method: esp_wifi::wifi::AuthMethod::WPA2Personal,
                        password: ap_password.try_into().unwrap(),
                        max_connections: max_connections,
                        channel: channel,
                        ssid_hidden: hide_ssid,
                        ..Default::default()
                    },
                );

                // Store Station Controller Configuration in Global Context
                CONTROLLER_CONFIG.lock(|c| c.borrow_mut().replace(config));
            }
            WiFiMode::Station => {
                // Capture SSID and Password from provided configuration
                let ssid = self.wifi_config.ssid.clone();
                let password = self.wifi_config.password.clone();

                // Station Configuration
                let config = Configuration::Client(ClientConfiguration {
                    ssid: ssid.try_into().unwrap(),
                    password: password.try_into().unwrap(),
                    channel: Some(self.wifi_config.channel),
                    auth_method: esp_wifi::wifi::AuthMethod::WPA2Personal,
                    ..Default::default()
                });

                // Store Station Controller Configuration in Global Context
                CONTROLLER_CONFIG.lock(|c| c.borrow_mut().replace(config));
            }
            _ => {}
        }
        // Send signal to connection to start collection
        START_COLLECTION.signal(collection_time_secs);
        // Wait for duration interval to finish
        Timer::after(Duration::from_secs(collection_time_secs)).await;
    }

    /// Sets the WiFi configuration for CSI collection
    pub fn set_wifi_config(&mut self, wifi_config: WiFiConfig) {
        self.wifi_config = wifi_config;
    }

    /// Sets the WiFi operation mode for CSI collection (Sniffer, Station, Access Point, etc.)
    pub fn set_op_mode(&mut self, op_mode: WiFiMode) {
        self.op_mode = op_mode;
    }

    /// Sets the CSI configuration for CSI collection
    pub fn set_csi_config(&mut self, csi_config: CSIConfig) {
        self.csi_config = csi_config;
    }

    /// Sets the traffic configuration for CSI collection
    pub fn set_traffic_config(&mut self, traffic_config: TrafficConfig) {
        self.traffic_config = traffic_config;
    }

    /// Enables or disables traffic generation
    pub fn set_traffic_enabled(&mut self, traffic_enabled: bool) {
        self.traffic_enabled = traffic_enabled;
    }

    /// Sets the network architechture for CSI collection
    pub fn set_net_arch(&mut self, net_arch: NetworkArchitechture) {
        self.net_arch = net_arch;
    }

    /// Initializes the CSI Collection System. This method starts the WiFi connection and Spawns the required tasks.
    /// The `EspWifiController` is also retuned in case it is needed for other purposes Ex. Bluetooth.
    pub fn init(
        &self,
        wifi: WIFI,
        wifi_hw: &'static EspWifiController<'static>,
        seed: u64,
        spawner: &Spawner,
        // Placeholder for future use to hold & signal captured CSI data
        // csi_buffer: Option<Signal<CriticalSectionRawMutex, Vec<i8, 612>>>,
    ) -> Result<&'static EspWifiController<'static>> {
        // Validate configuration
        self.validate()?;
        println!("Configuration Validated");

        let init = wifi_hw;

        // Instantiate Network Stack
        match self.op_mode {
            WiFiMode::AccessPoint => {
                // Create WiFi Interface and Controller Instances
                let (controller, wifi_interface) = esp_wifi::wifi::new(init, wifi).unwrap();

                // Create gateway IP address instance
                // This config doesnt get an IP address from router but runs DHCP server
                let gw_ip_addr_str = "192.168.2.1";
                let gw_ip_addr =
                    Ipv4Addr::from_str(gw_ip_addr_str).expect("failed to parse gateway ip");

                // Access Point IP Configuration
                let ap_ip_config = embassy_net::Config::ipv4_static(StaticConfigV4 {
                    address: Ipv4Cidr::new(gw_ip_addr, 24),
                    gateway: Some(gw_ip_addr),
                    dns_servers: Default::default(),
                });

                // Create Network Stack
                let (ap_stack, ap_runner) = embassy_net::new(
                    wifi_interface.ap,
                    ap_ip_config,
                    mk_static!(StackResources<3>, StackResources::<3>::new()),
                    seed,
                );

                let sniffer = controller.take_sniffer().unwrap();
                sniffer.set_promiscuous_mode(false).unwrap();

                // Spawn controller, runner, and DHCP server tasks
                spawner.spawn(net_task(ap_runner)).ok();
                spawner.spawn(run_dhcp(ap_stack, gw_ip_addr_str)).ok();
                spawner.spawn(connection(controller)).ok();
                // spawner.spawn(ap_stack_task(ap_stack)).ok();
            }

            // Station Mode
            WiFiMode::Station => {
                // Create WiFi Interface and Controller Instances
                let (controller, wifi_interface) = esp_wifi::wifi::new(&init, wifi).unwrap();

                // Configure Station DHCP Client
                let sta_config = embassy_net::Config::dhcpv4(Default::default());

                // Create Network Stack
                let (sta_stack, sta_runner) = embassy_net::new(
                    wifi_interface.sta,
                    sta_config,
                    mk_static!(StackResources<3>, StackResources::<3>::new()),
                    seed,
                );

                // Spawn Connection and Network Stack Polling Tasks
                spawner.spawn(connection(controller)).ok();
                spawner.spawn(net_task(sta_runner)).ok();
                spawner
                    .spawn(sta_stack_task(
                        sta_stack,
                        self.net_arch,
                        self.traffic_enabled,
                        self.traffic_config.traffic_interval_ms,
                        self.traffic_config.traffic_type.clone(),
                    ))
                    .ok();
            }
            // Access Point + Station Mode
            WiFiMode::AccessPointStation => {
                // Gets IP address from router and also runs DHCP server

                // Create AP/STA Interface
                let (controller, wifi_interface) = esp_wifi::wifi::new(&init, wifi).unwrap();

                // IP Configuration

                // Create gateway IP address instance
                // This config doesnt get an IP address from router but runs DHCP server for AP
                let gw_ip_addr_str = "192.168.2.1";
                let gw_ip_addr =
                    Ipv4Addr::from_str(gw_ip_addr_str).expect("failed to parse gateway ip");

                // Access Point IP Configuration
                let ap_ip_config = embassy_net::Config::ipv4_static(StaticConfigV4 {
                    address: Ipv4Cidr::new(gw_ip_addr, 24),
                    gateway: Some(gw_ip_addr),
                    dns_servers: Default::default(),
                });

                // Station (DHCP) IP Configuration
                let sta_ip_config = embassy_net::Config::dhcpv4(Default::default());

                // Init network stacks
                let (ap_stack, ap_runner) = embassy_net::new(
                    wifi_interface.ap,
                    ap_ip_config,
                    mk_static!(StackResources<3>, StackResources::<3>::new()),
                    seed,
                );
                let (sta_stack, sta_runner) = embassy_net::new(
                    wifi_interface.sta,
                    sta_ip_config,
                    mk_static!(StackResources<3>, StackResources::<3>::new()),
                    seed,
                );

                // Spawn controller, runner, and DHCP server tasks
                spawner.spawn(connection(controller)).ok();
                spawner.spawn(net_task(ap_runner)).ok();
                spawner.spawn(net_task(sta_runner)).ok();
                spawner.spawn(run_dhcp(ap_stack, gw_ip_addr_str)).ok();
                spawner
                    .spawn(sta_stack_task(
                        sta_stack,
                        self.net_arch,
                        self.traffic_enabled,
                        self.traffic_config.traffic_interval_ms,
                        self.traffic_config.traffic_type.clone(),
                    ))
                    .ok();
            }
            // Sniffer Mode
            WiFiMode::Sniffer => {
                println!("Starting Sniffer");
                // Create controller instance
                let (controller, _) = esp_wifi::wifi::new(&init, wifi).unwrap();
                // Take sniffer
                let sniffer = controller.take_sniffer().unwrap();
                sniffer.set_promiscuous_mode(true).unwrap();

                // Spawn controller to start sniffing
                spawner.spawn(connection(controller)).ok();
            }
        }
        Ok(init)
    }

    /// Validates the CSI Collection configuration/profile
    pub fn validate(&self) -> crate::Result<()> {
        // Validate WiFi configuration
        if self.wifi_config.channel < 1 || self.wifi_config.channel > 14 {
            return Err(crate::Error::ConfigError("Invalid WiFi channel"));
        }

        if self.wifi_config.max_retries > 10 {
            println!(
                "High number of WiFi retries configured: {}",
                self.wifi_config.max_retries
            );
        }

        if self.wifi_config.timeout_secs < 1 {
            return Err(crate::Error::ConfigError("WiFi timeout must be positive"));
        }

        if self.wifi_config.max_connections < 1 {
            return Err(crate::Error::ConfigError(
                "Maximum connections must be positive",
            ));
        }

        if self.traffic_config.traffic_interval_ms < 1 {
            return Err(crate::Error::ConfigError(
                "Traffic interval must be positive",
            ));
        }

        Ok(())
    }
}

// Embassy Tasks

#[embassy_executor::task]
async fn connection(mut controller: WifiController<'static>) {
    loop {
        // CSI collection is supported for all configurations
        // Don't start CSI collection until start collection is signalled
        let run_duration_secs = START_COLLECTION.wait().await;

        // Get configurations from global context
        let csi_config = COLLECTION_CONFIG.lock(|c| c.borrow().as_ref().unwrap().clone());
        // let net_arch = NETWORK_CONFIG.lock(|na| na.borrow().clone());
        let wifi_mode = OPERATION_MODE.lock(|om| om.borrow().clone());

        println!("Starting CSI Collection!");

        println!("Starting WiFi Connection...");
        // let connection = with_timeout(Duration::from_secs(run_duration_secs), async {
        let ap_events = enum_set!(
            WifiEvent::ApStaconnected
                | WifiEvent::ApStadisconnected
                | WifiEvent::ApStop
                | WifiEvent::StaDisconnected
                | WifiEvent::StaStop
        );
        loop {
            match esp_wifi::wifi::wifi_state() {
                WifiState::ApStarted | WifiState::StaConnected => {
                    let connection = with_timeout(Duration::from_secs(run_duration_secs), async {
                        loop {
                            let mut event = controller.wait_for_events(ap_events, true).await;
                            if event.contains(WifiEvent::ApStaconnected) {
                                // current_connections += 1;
                                println!("New STA Connected");
                            }
                            if event.contains(WifiEvent::ApStadisconnected) {
                                // current_connections -= 1;
                                println!("STA Disonnected");
                            }
                            if event.contains(WifiEvent::ApStop) {
                                // If stopped, try to reconnect
                                println!("AP connection stopped. Collection halted.");
                                Timer::after(Duration::from_millis(5000)).await;
                                break;
                            }
                            if event.contains(WifiEvent::StaDisconnected) {
                                println!("STA disconnected");
                                Timer::after(Duration::from_millis(5000)).await;
                                break;
                            }
                            if event.contains(WifiEvent::StaStop) {
                                // If stopped, try to reconnect
                                println!("STA connection stopped. Collection halted.");
                                Timer::after(Duration::from_millis(5000)).await;
                                break;
                            }
                            event.clear();
                        }
                    })
                    .await;

                    // Handle timeout result
                    match connection {
                        Ok(_) => {
                            println!("CSI Collection Concluded. Stopping Controller...");
                        }
                        Err(_) => {
                            println!("CSI Collection Concluded. Stopping Controller...");
                            controller.disconnect_async().await.unwrap();
                            controller.stop_async().await.unwrap();
                            START_COLLECTION.reset();
                            // START_TRAFFIC_GEN.reset();
                        }
                    }
                }
                _ => {}
            }
            if !matches!(controller.is_started(), Ok(true)) {
                // Set WiFi controller configuration only if not Sniffer mode
                if !matches!(wifi_mode, WiFiMode::Sniffer) {
                    // Get the controller configuration
                    let config = CONTROLLER_CONFIG.lock(|c| c.borrow().as_ref().unwrap().clone());
                    // Set the controller configuration
                    match controller.set_configuration(&config) {
                        Ok(_) => {
                            println!("WiFi Configuration Set: {:?}", config);
                        }
                        Err(_) => {
                            println!("WiFi Configuration Error");
                            // For Debug only
                            println!("Error Config: {:?}", config);
                        }
                    }
                }
                // Start WiFi
                println!("Starting WiFi");
                controller.start_async().await.unwrap();
                println!("Wifi Started!");

                // Check if Station mode is configured to establish a connection
                if matches!(wifi_mode, WiFiMode::Station | WiFiMode::AccessPointStation) {
                    // Connect WiFi
                    // Try to connect to the network up to 4 times
                    for attempt in 1..=3 {
                        println!("Connecting (attempt {}/{})...", attempt, 3);
                        match controller.connect_async().await {
                            Ok(_) => {
                                println!("Connected!");
                                break;
                            }
                            Err(e) => {
                                println!("Connection attempt {} failed: {:?}", attempt, e);
                                if attempt < 3 {
                                    println!("Trying again...");
                                    Timer::after(Duration::from_millis(3000)).await;
                                } else {
                                    println!("All connection attempts failed. Giving up.");
                                }
                            }
                        }
                    }
                }

                // Set the CSI Configuration and Connect Callback (should be passed to function)
                let csi = build_csi_config(csi_config.clone());

                // Create default for date time
                let mut date_time = &DateTime {
                    captured_at: Instant::now(),
                    captured_millis: 0,
                    captured_secs: 0,
                };

                // Retreive the time struct from global context if available
                if DATE_TIME_VALID.load(core::sync::atomic::Ordering::Relaxed) {
                    date_time = DATE_TIME.get().await;
                }

                if !matches!(
                    wifi_mode,
                    WiFiMode::AccessPoint | WiFiMode::AccessPointStation
                ) {
                    // CSI callback should calculate the time elapsed using Instant now and getting new time
                    controller
                        .set_csi(csi, |info: esp_wifi::wifi::wifi_csi_info_t| {
                            let csi_data = info.buf;
                            let csi_data_len = info.len;
                            let mac = info.mac;
                            let rx_ctrl = info.rx_ctrl;
                            let rssi = if rx_ctrl.rssi() > 127 {
                                rx_ctrl.rssi() - 256
                            } else {
                                rx_ctrl.rssi()
                            };

                            // 612 is the maximum possible amount of data bytes that can be recieved
                            // https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-guides/wifi.html#wi-fi-channel-state-information

                            let mut data_buffer: Vec<i8, 612> = Vec::new();
                            for data in 0..csi_data_len {
                                unsafe {
                                    let value = *csi_data.add(data as usize);
                                    data_buffer.push(value).expect("Exceeded maximum capacity");
                                }
                            }

                            // CSI Received Packet Radio Metadata Header Value Interpretations for non-ESP32-C6 devices

                            // rssi: Received Signal Strength Indicator(RSSI) of packet. unit: dBm.
                            // rate: PHY rate encoding of the packet. Only valid for non HT(11bg) packet.
                            // sig_mode: Protocol of the received packet, 0: non HT(11bg) packet; 1: HT(11n) packet; 3: VHT(11ac) packet.
                            // mcs: Modulation Coding Scheme. If is HT(11n) packet, shows the modulation, range from 0 to 76(MSC0 ~ MCS76).
                            // cwb: Channel Bandwidth of the packet. 0: 20MHz; 1: 40MHz.
                            // smoothing: Set to 1 indicates that channel estimate smoothing is recommended. Set to 0 indicates that only per-carrier independent (unsmoothed) channel estimate is recommended.
                            // not_sounding: Set to 0 indicates that PPDU is a sounding PPDU. Set to 1 indicates that the PPDU is not a sounding PPDU. Sounding PPDU is used for channel estimation by the request receiver.
                            // aggregation: Aggregation. 0: MPDU packet; 1: AMPDU packet
                            // stbc: Space Time Block Code(STBC). 0: non STBC packet; 1: STBC packet.
                            // fec_coding: Forward Error Correction (FEC). Flag is set for 11n packets which are LDPC.
                            // sgi: Short Guide Interval (SGI). 0: Long GI; 1: Short GI.
                            // noise_floor: noise floor of Radio Frequency Module(RF). unit: dBm.
                            // ampdu_cnt: The number of subframes aggregated in AMPDU.
                            // channel: Primary channel on which this packet is received.
                            // secondary_channel: Secondary channel on which this packet is received. 0: none; 1: above; 2: below.
                            // timestamp: Timestamp. The local time when this packet is received. It is precise only if modem sleep or light sleep is not enabled. The timer is started when controller.start() is returned. unit: microsecond.
                            // noise_floor: Noise floor of Radio Frequency Module(RF). unit: dBm.
                            // ant: Antenna number from which this packet is received. 0: WiFi antenna 0; 1: WiFi antenna 1.
                            // noise_floor: Noise floor of Radio Frequency Module(RF). unit: dBm.
                            // sig_len: Length of packet including Frame Check Sequence(FCS).
                            // rx_state: State of the packet. 0: no error; others: error numbers which are not public.

                            // CSI Received Packet Radio Metadata Header Value Interpretations for ESP32-C6 devices

                            // rssi: Received Signal Strength Indicator (RSSI) of the packet, in dBm.
                            // rate: PHY rate encoding of the packet. Only valid for non-HT (802.11b/g) packets.
                            // sig_len: Length of the received packet including the Frame Check Sequence (FCS).
                            // rx_state: Reception state of the packet: 0 for no error, others indicate error codes.
                            // dump_len: Length of the dump buffer.
                            // he_sigb_len: Length of HE-SIG-B field (802.11ax).
                            // cur_single_mpdu: Indicates if this is a single MPDU.
                            // cur_bb_format: Current baseband format.
                            // rx_channel_estimate_info_vld: Channel estimation validity.
                            // rx_channel_estimate_len: Length of the channel estimation.
                            // second: Timing information in seconds.
                            // channel: Primary channel on which the packet is received.
                            // noise_floor: Noise floor of the Radio Frequency module, in dBm.
                            // is_group: Indicates if this is a group-addressed frame.
                            // rxend_state: End state of the packet reception.
                            // rxmatch3: Indicate whether the reception frame is from interface 3.
                            // rxmatch2: Indicate whether the reception frame is from interface 2.
                            // rxmatch1: Indicate whether the reception frame is from interface 1.
                            // rxmatch0: Indicate whether the reception frame is from interface 0.

                            println!("New CSI Data");

                            // Calculate Elapsed time here and add offset to date_time then call to calculate new time
                            // This code should activate only if architechture supports capturing NTP
                            if DATE_TIME_VALID.load(core::sync::atomic::Ordering::Relaxed) {
                                let elapsed_time =
                                    Instant::now().duration_since(date_time.captured_at);

                                // Add seconds and adjust for overflow from milliseconds
                                let total_time_secs =
                                    date_time.captured_secs + elapsed_time.as_secs();

                                // Add milliseconds and adjust if they exceed 1000
                                let total_millis =
                                    date_time.captured_millis + elapsed_time.as_millis();
                                let extra_secs = total_millis / 1000; // 1000ms = 1 second
                                let final_millis = total_millis % 1000; // Remainder in milliseconds

                                // Add extra seconds from milliseconds overflow to total seconds
                                let total_time_secs = total_time_secs + extra_secs;

                                // Now call the date-time conversion function
                                let (year, month, day, hour, minute, second, millis) =
                                    unix_to_date_time(total_time_secs, final_millis);

                                println!(
                                    "Recieved at {:04}-{:02}-{:02} {:02}:{:02}:{:02}.{:03}",
                                    year, month, day, hour, minute, second, millis
                                );
                            }
                            println!(
                                "mac: {:02X}:{:02X}:{:02X}:{:02X}:{:02X}:{:02X}",
                                mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]
                            );
                            println!("rssi: {}", rssi);
                            print_csi_metadata(info);
                            println!("data length: {}", csi_data_len);
                            println!("csi raw data:");
                            #[cfg(feature = "defmt")]
                            println!("{=[?]}", data_buffer);
                            #[cfg(feature = "println")]
                            println!("{:?}", data_buffer);
                        })
                        .unwrap();

                    println!("Waiting for CSI data...");
                }
            }
        }
    }
}

// Placeholder for future use if an AP stack is required to process packets
// #[embassy_executor::task]
// async fn ap_stack_task(ap_stack: Stack<'static>) {
//     let mut rx_buffer = [0; 1024];
//     let mut tx_buffer = [0; 1024];
//     let mut rx_meta: [PacketMetadata; 128] = [PacketMetadata::EMPTY; 128];
//     let mut tx_meta: [PacketMetadata; 128] = [PacketMetadata::EMPTY; 128];

//     let mut socket = UdpSocket::new(
//         ap_stack,
//         &mut rx_meta,
//         &mut rx_buffer,
//         &mut tx_meta,
//         &mut tx_buffer,
//     );

//     println!("Binding");

//     socket.bind(10987).unwrap();

//     let mut buf = [0u8; 512];

//     loop {
//         // Wait to receive a packet
//         let (n, sender_endpoint) = socket.recv_from(&mut buf).await.unwrap();

//         println!("Received {} bytes from {:?}", n, sender_endpoint);
//         println!("Received array: {:?}", buf);
//     }
// }

#[embassy_executor::task]
async fn sta_stack_task(
    sta_stack: Stack<'static>,
    net_arch: NetworkArchitechture,
    traffic_en: bool,
    traffic_interval: u64,
    traffic_type: TrafficType,
) {
    println!("STA Stack Task Running");

    // Acquire and store IP information for gateway and client after configuration is up

    // Check if link is up
    sta_stack.wait_link_up().await;
    println!("Link is up!");

    // Create instance to store acquired IP information
    let mut ip_info = IpInfo {
        local_address: Ipv4Cidr::new(Ipv4Addr::UNSPECIFIED, 24),
        gateway_address: Ipv4Address::UNSPECIFIED,
    };

    println!("Acquiring config...");
    sta_stack.wait_config_up().await;
    println!("Config Acquired");

    // Print out acquired IP configuration
    loop {
        if let Some(config) = sta_stack.config_v4() {
            ip_info.local_address = config.address;
            ip_info.gateway_address = config.gateway.unwrap();
            println!("Got IP: {:?}", ip_info.local_address);
            println!("Gateway IP: {:?}", ip_info.gateway_address);
            break;
        }
        Timer::after(Duration::from_millis(500)).await;
    }

    // Check if selected network architechture supports NTP time stamp retrieval
    // Capturing time is supported only by architechtures that connect to a commercial router with an internet connection
    // These are RouterStation and RouterAccessPointStation
    match net_arch {
        NetworkArchitechture::RouterStation | NetworkArchitechture::RouterAccessPointStation => {
            // Get Current SNTP unix time values
            match get_sntp_time(sta_stack).await {
                Ok((seconds, milliseconds)) => {
                    // Convert captured time to date/time values
                    let time_capture = unix_to_date_time(seconds.into(), milliseconds);

                    // Print the time captured for validation
                    println!(
                        "Time: {:04}-{:02}-{:02} {:02}:{:02}:{:02}.{:03}",
                        time_capture.0,
                        time_capture.1,
                        time_capture.2,
                        time_capture.3,
                        time_capture.4,
                        time_capture.5,
                        time_capture.6
                    );

                    // Store the captured time instant values to DateTime struct
                    let time = DateTime {
                        captured_at: Instant::now(),
                        captured_secs: seconds as u64,
                        captured_millis: milliseconds,
                    };

                    // Move DateTime struct to Global Context
                    match DATE_TIME.init(time) {
                        Ok(_) => {
                            println!("Time Captured");
                            DATE_TIME_VALID.store(true, core::sync::atomic::Ordering::Relaxed);
                        }
                        Err(_) => {
                            println!("Failed to Capture Time");
                            DATE_TIME_VALID.store(false, core::sync::atomic::Ordering::Relaxed);
                        }
                    }
                }
                Err(_) => {
                    println!("Failed to get SNTP time, Proceeding with default.");
                    DATE_TIME_VALID.store(false, core::sync::atomic::Ordering::Relaxed);
                }
            }
        }
        NetworkArchitechture::AccessPointStation | NetworkArchitechture::Sniffer => {
            // Do Nothing, No Connection to Internet to Sync Time
            println!("NTP time not captured. Configured architechture does not support.");
        }
    }

    // Check if traffic generation is enabled
    if traffic_en {
        println!("Starting Traffic Generation");
        // Match type of traffic
        match traffic_type {
            TrafficType::UDP => {
                let mut rx_buffer = [0; 1024];
                let mut tx_buffer = [0; 1024];
                let mut rx_meta: [PacketMetadata; 128] = [PacketMetadata::EMPTY; 128];
                let mut tx_meta: [PacketMetadata; 128] = [PacketMetadata::EMPTY; 128];

                let mut socket = UdpSocket::new(
                    sta_stack,
                    &mut rx_meta,
                    &mut rx_buffer,
                    &mut tx_meta,
                    &mut tx_buffer,
                );

                println!("Binding");

                // Bind to a local port
                socket.bind(10987).unwrap();

                // Send to some unreachable port to trigger response
                // Using same local port number
                let endpoint =
                    IpEndpoint::new(embassy_net::IpAddress::Ipv4(ip_info.gateway_address), 10987);

                loop {
                    // Send a random byte to gateway
                    socket.send_to(&[13], endpoint).await.unwrap();
                    // Wait for user specified duration
                    Timer::after(Duration::from_millis(traffic_interval)).await;
                    println!("PING!");
                }
            }
            TrafficType::ICMPPing => {
                // To Implement when raw becomes available in embassy-net
                // Create a raw packet and ping gateway IP

                let mut rx_buffer = [0; 64];
                let mut tx_buffer = [0; 64];
                let mut rx_meta: [RawPacketMetadata; 1] = [RawPacketMetadata::EMPTY; 1];
                let mut tx_meta: [RawPacketMetadata; 1] = [RawPacketMetadata::EMPTY; 1];

                let raw_socket = RawSocket::new::<WifiDevice<'_>>(
                    sta_stack,
                    IpVersion::Ipv4,
                    IpProtocol::Icmp,
                    &mut rx_meta,
                    &mut rx_buffer,
                    &mut tx_meta,
                    &mut tx_buffer,
                );

                // Buffer to hold ICMP Packet
                let mut icmp_buffer = [0u8; 12];

                // Create ICMP Packet
                let mut icmp_packet = Icmpv4Packet::new_unchecked(&mut icmp_buffer[..]);

                // Create an ICMPv4 Echo Request
                let icmp_repr = Icmpv4Repr::EchoRequest {
                    ident: 0x22b,
                    seq_no: 0,
                    data: &[0xDE, 0xAD, 0xBE, 0xEF],
                };

                // Serialize the ICMP representation into the packet
                icmp_repr.emit(&mut icmp_packet, &ChecksumCapabilities::default());

                // Buffer for the full IPv4 packet
                let mut ipv4_buffer = [0u8; 64];

                // Define the IPv4 representation
                let ipv4_repr = Ipv4Repr {
                    src_addr: ip_info.local_address.address(), // Replace with your source IP
                    dst_addr: ip_info.gateway_address,
                    payload_len: icmp_repr.buffer_len(),
                    hop_limit: 64, // Time-to-live value
                    next_header: IpProtocol::Icmp,
                };

                println!("Creating IPv4 Packet");

                // Create the IPv4 packet
                let mut ipv4_packet = Ipv4Packet::new_unchecked(&mut ipv4_buffer);

                // Serialize the IPv4 representation into the packet
                ipv4_repr.emit(&mut ipv4_packet, &ChecksumCapabilities::default());

                // Copy the ICMP packet into the IPv4 packet's payload
                ipv4_packet
                    .payload_mut()
                    .copy_from_slice(icmp_packet.into_inner());

                // IP Packet buffer that will be sent
                let ipv4_packet_buffer = ipv4_packet.into_inner();

                loop {
                    // Send raw packet
                    raw_socket.send(ipv4_packet_buffer).await;

                    // Wait for user specified duration
                    Timer::after(Duration::from_millis(traffic_interval)).await;
                }
            }
        }
    }
}

#[embassy_executor::task(pool_size = 2)]
async fn net_task(mut runner: Runner<'static, WifiDevice<'static>>) {
    println!("Network Task Running");
    runner.run().await
}

#[embassy_executor::task]
async fn run_dhcp(stack: Stack<'static>, gw_ip_addr: &'static str) {
    use core::net::{Ipv4Addr, SocketAddrV4};

    use edge_dhcp::{
        io::{self, DEFAULT_SERVER_PORT},
        server::{Server, ServerOptions},
    };
    use edge_nal::UdpBind;
    use edge_nal_embassy::{Udp, UdpBuffers};

    let ip = Ipv4Addr::from_str(gw_ip_addr).expect("DHCP task failed to parse gateway ip");

    let mut buf = [0u8; 1500];

    let mut gw_buf = [Ipv4Addr::UNSPECIFIED];

    let buffers = UdpBuffers::<3, 1024, 1024, 10>::new();
    let unbound_socket = Udp::new(stack, &buffers);
    let mut bound_socket = unbound_socket
        .bind(core::net::SocketAddr::V4(SocketAddrV4::new(
            Ipv4Addr::UNSPECIFIED,
            DEFAULT_SERVER_PORT,
        )))
        .await
        .unwrap();

    println!("DHCP Server Running");
    let mut server = Server::<_, 64>::new_with_et(ip);
    loop {
        _ = io::server::run(
            &mut server,
            &ServerOptions::new(ip, Some(&mut gw_buf)),
            &mut bound_socket,
            &mut buf,
        )
        .await
        .inspect_err(|_e| println!("DHCP Server Error"));
        println!("DHCP Buffer: {:?}", buf);
        Timer::after(Duration::from_millis(500)).await;
    }
}

// Supporting Functions

// Function to get timestamp from NTP
async fn get_sntp_time(stack: Stack<'_>) -> Result<(u32, u64)> {
    let mut rx_buffer = [0; 1024];
    let mut tx_buffer = [0; 1024];
    let mut rx_meta: [PacketMetadata; 128] = [PacketMetadata::EMPTY; 128];
    let mut tx_meta: [PacketMetadata; 128] = [PacketMetadata::EMPTY; 128];

    let mut sntp_socket = UdpSocket::new(
        stack,
        &mut rx_meta,
        &mut rx_buffer,
        &mut tx_meta,
        &mut tx_buffer,
    );

    sntp_socket.bind(12345).unwrap();

    let mut sntp_packet = [0u8; 48];
    sntp_packet[0] = 0x23; // LI = 0, VN = 4, Mode = 3

    let Ok(ntp_server_addrs) = stack
        .dns_query(NTP_SERVER, smoltcp::wire::DnsQueryType::A)
        .await
    else {
        return Err(error::Error::ConfigError(""));
    };

    // Find the first IPv4 address in the result
    let Some(ntp_server_addr) = ntp_server_addrs.iter().find_map(|addr| match addr {
        IpAddress::Ipv4(ip) => Some(*ip), // Return the first IPv4 address
        _ => None,
    }) else {
        return Err(error::Error::ConfigError(""));
    };

    let Ok(_) = sntp_socket
        .send_to(&sntp_packet, (ntp_server_addr, NTP_PORT))
        .await
    else {
        return Err(error::Error::ConfigError(""));
    };

    let mut ntp_response = [0_u8; 48];
    let Ok((len, _)) = sntp_socket.recv_from(&mut ntp_response).await else {
        println!("Receive failed");
        return Err(error::Error::ConfigError(""));
    };

    if len < 48 {
        return Err(crate::Error::SystemError("Incomplete NTP response"));
    }

    let transmit_secs = u32::from_be_bytes(ntp_response[40..44].try_into().unwrap());
    let transmit_frac = u32::from_be_bytes(ntp_response[44..48].try_into().unwrap());

    // Adjust for UNIX epoch
    let unix_seconds = transmit_secs - NTP_UNIX_OFFSET;

    // Convert fractional seconds to milliseconds
    let milliseconds = ((transmit_frac as u64) * 1000) >> 32;

    Ok((unix_seconds, milliseconds))
}

// Function to convert UNIX timestamp to date and time
fn unix_to_date_time(unix_seconds: u64, unix_millis: u64) -> (u64, u64, u64, u64, u64, u64, u64) {
    const SECONDS_PER_MINUTE: u64 = 60;
    const SECONDS_PER_HOUR: u64 = 3600;
    const SECONDS_PER_DAY: u64 = 86400;

    // Days since epoch
    let mut days_since_epoch = unix_seconds / SECONDS_PER_DAY;
    let seconds_in_day = unix_seconds % SECONDS_PER_DAY;

    // Calculate hour, minute, second
    let hour = seconds_in_day / SECONDS_PER_HOUR;
    let minute = (seconds_in_day % SECONDS_PER_HOUR) / SECONDS_PER_MINUTE;
    let second = seconds_in_day % SECONDS_PER_MINUTE;

    // Calculate year, month, day
    let mut year = 1970;
    while days_since_epoch >= days_in_year(year) {
        days_since_epoch -= days_in_year(year);
        year += 1;
    }

    let mut month = 1;
    while days_since_epoch >= days_in_month(year, month) {
        days_since_epoch -= days_in_month(year, month);
        month += 1;
    }

    let day = days_since_epoch + 1;

    // Return the calculated values
    (year, month, day, hour, minute, second, unix_millis)
}

// Function to check if a year is a leap year
fn is_leap_year(year: u64) -> bool {
    (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)
}

// Function to get the number of days in a year
fn days_in_year(year: u64) -> u64 {
    if is_leap_year(year) {
        366
    } else {
        365
    }
}

// Function to get the number of days in a month
fn days_in_month(year: u64, month: u64) -> u64 {
    match month {
        1 => 31,
        2 => {
            if is_leap_year(year) {
                29
            } else {
                28
            }
        }
        3 => 31,
        4 => 30,
        5 => 31,
        6 => 30,
        7 => 31,
        8 => 31,
        9 => 30,
        10 => 31,
        11 => 30,
        12 => 31,
        _ => 0,
    }
}

#[cfg(feature = "esp32c6")]
fn build_csi_config(csi_config: CSIConfig) -> CsiConfig {
    CsiConfig {
        enable: csi_config.enable,
        acquire_csi_legacy: csi_config.acquire_csi_legacy,
        acquire_csi_ht20: csi_config.acquire_csi_ht20,
        acquire_csi_ht40: csi_config.acquire_csi_ht40,
        acquire_csi_su: csi_config.acquire_csi_su,
        acquire_csi_mu: csi_config.acquire_csi_mu,
        acquire_csi_dcm: csi_config.acquire_csi_dcm,
        acquire_csi_beamformed: csi_config.acquire_csi_beamformed,
        acquire_csi_he_stbc: csi_config.acquire_csi_he_stbc,
        val_scale_cfg: csi_config.val_scale_cfg,
        dump_ack_en: csi_config.dump_ack_en,
        reserved: csi_config.reserved,
    }
}

#[cfg(not(feature = "esp32c6"))]
fn build_csi_config(csi_config: CSIConfig) -> CsiConfig {
    CsiConfig {
        lltf_en: csi_config.lltf_enabled,
        htltf_en: csi_config.htltf_enabled,
        stbc_htltf2_en: csi_config.stbc_htltf2_enabled,
        ltf_merge_en: csi_config.ltf_merge_enabled,
        channel_filter_en: csi_config.channel_filter_enabled,
        manu_scale: csi_config.manu_scale,
        shift: csi_config.shift,
        dump_ack_en: csi_config.dump_ack_en,
    }
}

#[cfg(not(feature = "esp32c6"))]
fn print_csi_metadata(info: esp_wifi::wifi::wifi_csi_info_t) {
    let rx_ctrl = info.rx_ctrl;
    println!("rate: {}", rx_ctrl.rate());
    println!("noise floor: {}", rx_ctrl.noise_floor());
    println!("channel: {}", rx_ctrl.channel());
    println!("timestamp: {}", rx_ctrl.timestamp());
    println!("sig len: {}", rx_ctrl.sig_len());
    println!("rx state: {}", rx_ctrl.rx_state());
    println!("secondary channel: {}", rx_ctrl.secondary_channel());
    println!("sgi: {}", rx_ctrl.sgi());
    println!("ant: {}", rx_ctrl.ant());
    println!("ampdu cnt: {}", rx_ctrl.ampdu_cnt());
    println!("sig_mode: {}", rx_ctrl.sig_mode());
    println!("mcs: {}", rx_ctrl.mcs());
    println!("cwb: {}", rx_ctrl.cwb());
    println!("smoothing: {}", rx_ctrl.smoothing());
    println!("not sounding: {}", rx_ctrl.not_sounding());
    println!("aggregation: {}", rx_ctrl.aggregation());
    println!("stbc: {}", rx_ctrl.stbc());
    println!("fec coding: {}", rx_ctrl.fec_coding());
}

#[cfg(feature = "esp32c6")]
fn print_csi_metadata(info: esp_wifi::wifi::wifi_csi_info_t) {
    let rx_ctrl = info.rx_ctrl;
    println!("rate: {}", rx_ctrl.rate());
    println!("noise floor: {}", rx_ctrl.noise_floor());
    println!("channel: {}", rx_ctrl.channel());
    println!("timestamp: {}", rx_ctrl.timestamp());
    println!("sig len: {}", rx_ctrl.sig_len());
    println!("rx state: {}", rx_ctrl.rx_state());
    println!("dump len: {}", rx_ctrl.dump_len());
    println!("he sigb len: {}", rx_ctrl.he_sigb_len());
    println!("cur single mpdu: {}", rx_ctrl.cur_single_mpdu());
    println!("cur bb format: {}", rx_ctrl.cur_bb_format());
    println!(
        "rx channel estimate info vld: {}",
        rx_ctrl.rx_channel_estimate_info_vld()
    );
    println!(
        "rx channel estimate len: {}",
        rx_ctrl.rx_channel_estimate_len()
    );
    println!("second: {}", rx_ctrl.second());
    println!("is group: {}", rx_ctrl.is_group());
    println!("rxend state: {}", rx_ctrl.rxend_state());
    println!("rxmatch3: {}", rx_ctrl.rxmatch3());
    println!("rxmatch2: {}", rx_ctrl.rxmatch2());
    println!("rxmatch1: {}", rx_ctrl.rxmatch1());
    println!("rxmatch0: {}", rx_ctrl.rxmatch0());
}
